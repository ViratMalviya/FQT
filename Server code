# =========================
# SERVER.PY
# =========================

from flask import Flask, request, send_file
import torch
from model import QuantumTrainGenerator, TargetCNN

app = Flask(__name__)
PORT = 5000

# Number of clients required before aggregation
EXPECTED_CLIENTS = 2   # Change this based on how many clients you run

# Initialize global model
global_model = QuantumTrainGenerator(TargetCNN())
updates = []

@app.route("/get_model", methods=["GET"])
def get_model():
    torch.save(global_model.state_dict(), "global.pt")
    return send_file("global.pt", as_attachment=True)

@app.route("/send_update", methods=["POST"])
def receive_update():
    update = torch.load(request.files["update"])
    updates.append(update)

    print(f"Received update ({len(updates)}/{EXPECTED_CLIENTS})")

    # Aggregate automatically when enough clients send updates
    if len(updates) >= EXPECTED_CLIENTS:
        print("Enough updates received. Aggregating...")

        with torch.no_grad():
            averaged_state = {}
            for k in global_model.state_dict().keys():
                averaged_state[k] = torch.stack(
                    [u[k] for u in updates]
                ).mean(dim=0)

            global_model.load_state_dict(averaged_state)

        updates.clear()
        print("Aggregation done\n")

    return "OK"

if __name__ == "__main__":
    print("Server running")
    app.run(host="0.0.0.0", port=PORT)
